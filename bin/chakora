#!/usr/bin/perl -w
#
# /  __ \ |         | |                  
# | /  \/ |__   __ _| | _____  _ __ __ _ 
# | |   | '_ \ / _` | |/ / _ \| '__/ _` |
# | \__/\ | | | (_| |   < (_) | | | (_| |
#  \____/_| |_|\__,_|_|\_\___/|_|  \__,_|
#          Chakora IRC Services
#
# Copyright (c) 2010 The Chakora Project. All rights reserved.
# Released under The BSD License (docs/LICENSE - http://www.opensource.org/licenses/bsd-license.php)
package Chakora;
use strict;
use warnings;
use IO::Socket;
use Config::Scoped;
use File::Data;
use Getopt::Long;
use POSIX qw(setsid strftime);
use Term::ANSIColor;
use DBI;
use DBD::File;
use DBD::CSV;
use SQL::Statement;
use Text::CSV_XS;
use Sub::Delete;
use Digest::Whirlpool;
use Digest::HMAC;
use FindBin qw($Bin);
use lib "$Bin/../src";

our $ROOT_SRC = "$Bin/../src";
our $ROOT_ETC = "$Bin/../etc";

my (%options, %svsuid);
our ($SERVICES_STARTTIME, $SERVICES_VERSION);

# Get command line options
GetOptions("help" => \$options{help},
    "debug" => \$options{debug},
);

# Handle --help
if ($options{help}) {
    print("**Chakora Help**\n");
    print("--debug = Run in debug mode\n");
    print("--help = Return this help menu\n");
    exit;
}

# Define our version
$SERVICES_VERSION = 'Chakora 1.0-dev';

# Okay! Here we go!
print color 'bold red';
print("Chakora IRC Services Version 1.0-dev\n");
print color 'bold green';
print("\n");
print("By continuing you are hereby stating that\n"); 
print("you have read and agreed to docs/LICENSE\n");
print("\n");
print("Many thanks to the developers of Chakora for\n");
print("their hard work on this software!\n");
print("\n");
print("Developers: starcoder, MattB, chazz, Freelancer\n");
print("\n");
print("If you require support, feel free to join our\n");
print("official support chatroom!\n");
print("\n");
print("Host: irc.technoirc.net | Channel: #chakora\n"); sleep 2;
print("\n\n");
print color 'reset';
print("Chakora IRC Services started on ".strftime('%D at %I:%M:%S %p.', localtime)."\n"); sleep 1;
$SERVICES_STARTTIME = time();
svsflog("chakora", "Chakora IRC Services started.");

# Don't allow Chakora to run as root
if (`whoami` eq "root\n") { 
    error("chakora", "We forbid running Chakora as root."); 
}

# If we're in debug mode, set a variable letting Chakora know that.
if ($options{debug}) {
        our $IN_DEBUG = 1;
}

# Get configuration values
my $conf = Config::Scoped->new(
    file => $ROOT_ETC."/chakora.conf",
) or die("We couldn't open the config file!\n");

# Put them into variables	
my $settings = $conf->parse;

# We do not support Windows
if ($^O =~ /win/i) {
	taint("Operating System: Windows is not supported by Chakora.");
}

# Define SIG handlers
$SIG{'INT'} = \&INT_handler;

# Create some variables for later use
our (%rawcmds, %PROTO_SETTINGS, %COMMANDS, %HELP, %MODULE);

if (lc(config('server', 'ircd')) eq 'inspircd') {
	print("[MODULES] Loading protocol: InspIRCd 1.2/2.0\n");
    require Chakora::Protocol::InspIRCd or error("chakora", "Protocol module failed to load: $!");
} elsif (lc(config('server', 'ircd')) eq 'charybdis') {
	print("[MODULES] Loading protocol: Charybdis\n");
    require Chakora::Protocol::Charybdis or error("chakora", "Protocol module failed to load: $!");
} else {
    error("chakora", "This protocol isn't supported by Chakora.");
};
require Chakora::Server::Events;

if (config('services', 'allow_taint')) {
	print("[WARNING] ALLOW_TAINT is enabled, your rights to support are hereby voided.\n");
}


# Create database operator
if (!-d "$ROOT_ETC/data") {
	`mkdir $ROOT_ETC/data`;
}
our $SVSDB = DBI->connect("DBI:CSV:f_dir=$ROOT_ETC/data") or error("chakora", "Unable to open database: ".$DBI::errstr);

# Prepare the database
if (!-e "$ROOT_ETC/data/accounts") {
	$SVSDB->do("CREATE TABLE accounts (id INT, accountname TEXT, pass TEXT, email TEXT, date INT, lasthost TEXT, lastseen INT, flags TEXT)");
}
if (!-e "$ROOT_ETC/data/nicks") {
	$SVSDB->do("CREATE TABLE nicks (id INT, accountname TEXT, nick TEXT)");
}
if (!-e "$ROOT_ETC/data/chans") {
	$SVSDB->do("CREATE TABLE chans (id INT, name TEXT, date INT, mlock TEXT, flags TEXT, entrymsg TEXT, ts TEXT)");
}
if (!-e "$ROOT_ETC/data/vhosts") {
	$SVSDB->do("CREATE TABLE vhosts (id INT, user TEXT, host TEXT, date INT, setby TEXT)");
}
if (!-e "$ROOT_ETC/data/flags") {
	$SVSDB->do("CREATE TABLE flags (chan TEXT, user TEXT, flags TEXT)");
}

# Fork into the background unless --debug was specified
unless ($options{debug}) {
    our $IN_DEUBG = 0;
    print("Becoming a daemon...\n");
    open STDIN, '/dev/null'   or error("chakora", "Can't read /dev/null: $!");
    open STDOUT, '>>/dev/null' or error("chakora", "Can't write to /dev/null: $!");
    open STDERR, '>>/dev/null' or error("chakora", "Can't write to /dev/null: $!");
    my $pid = fork();
    unless ($pid == 0) {
        svsflog("chakora", "Successfully forked into the background. Process ID: ".$pid);
        exit;
    }
    setsid or error("chakora", "Can't start a new session: $!");
}

# Open the socket and connect to the server
my $socket = IO::Socket::INET->new(
    Proto => "tcp",
    LocalAddr => config('server', 'vhost'),
    PeerAddr => config('server', 'host'),
    PeerPort => config('server', 'port'),
) or error("chakora", "Connection to ".config('server', 'host')." failed.\n");

# Create some variables for later use
my ($data, $ex, @ex, $mtext);
our $synced = 0;
our ($INSPIRCD_SERVICES_ACCOUNT_MOD, $INSPIRCD_SERVICE_PROTECT_MOD);
my ($SERVICES_MSGSERVICE, $USER, $SERVICES_MSGSERVICEA);

# Connect!
irc_connect();

if (config('xmlrpc', 'use'))
{
	print ("XMLRPC: You have specified that you want to use the xmlrpc, however we have not fully finished it. Ignorinng.\n");
}
my $saa = config('services', 'autoload'); 
my @sab = split(' ', $saa);
my ($sac); 
foreach $sac (@sab) { 
    eval { require $ROOT_SRC."/../modules/".lc($sac).".pm"; }; 
}

while (1) {
	$data = <$socket>;
	unless (defined($data)) {
		 # There is no connection! Lets reconnect!
		 sleep 2;
		 $synced = 0;
		 $socket = IO::Socket::INET->new(
				Proto => "tcp",
				LocalAddr => config('server', 'vhost'),
				PeerAddr => config('server', 'host'),
				PeerPort => config('server', 'port'),
		) or error("chakora", "Connection to ".config('server', 'host')." failed.\n");
		irc_connect();
	}
    chomp($data);
    undef $ex;
    undef $mtext;
    @ex = split(' ', $data);
    $mtext = substr($data,index($data,":",index($data,":")+1)+1);

    print("[IRC] ".$data."\n");
    $USER = substr($ex[0], 1);

    if ($ex[0] eq 'CAPAB' and $ex[1] eq 'MODULES' and lc(config('server', 'ircd')) eq 'inspircd') {
        # taint if m_invisible is loaded, this will not be removed - so don't ask
        if ($data =~ m/m_invisible.so/) {
            taint("InspIRCd: m_invisible is loaded.");
        }
        # check for m_services_account
        if ($data =~ m/m_services_account.so/) {
            $INSPIRCD_SERVICES_ACCOUNT_MOD = 1;
        }
        # check for m_servprotect
        if ($data =~ m/m_servprotect.so/) {
            $INSPIRCD_SERVICE_PROTECT_MOD = 1;
        }
    }
    # Check for status modes
    elsif ($ex[0] eq 'CAPAB' and $ex[1] eq 'CAPABILITIES' and lc(config('server', 'ircd')) eq 'inspircd') {
        if ($data =~ m/PREFIX=(qaohv)/) {
            $PROTO_SETTINGS{owner} = 'q';
            $PROTO_SETTINGS{admin} = 'a';
            $PROTO_SETTINGS{halfop} = 'h';
        } elsif ($data =~ m/PREFIX=(aohv)/) {
            $PROTO_SETTINGS{admin} = 'a';
            $PROTO_SETTINGS{halfop} = 'h';
        } elsif ($data =~ m/PREFIX=(qohv)/) {
            $PROTO_SETTINGS{owner} = 'q';
            $PROTO_SETTINGS{halfop} = 'h';
        } elsif ($data =~ m/PREFIX=(qaov)/) {
            $PROTO_SETTINGS{owner} = 'q';
            $PROTO_SETTINGS{admin} = 'a';
        } elsif ($data =~ m/PREFIX=(aov)/) {
            $PROTO_SETTINGS{admin} = 'a';
        } elsif ($data =~ m/PREFIX=(qov)/) {
            $PROTO_SETTINGS{owner} = 'q';
        } elsif ($data =~ m/PREFIX=(ohv)/) {
            $PROTO_SETTINGS{halfop} = 'h';
        } else {
            print("[PROTOCOL] +qah are disabled, we recommend enabling these then restarting services.\n");
        }
    }
    # InspIRCd: CAPAB END recieved
    elsif ($ex[0] eq 'CAPAB' and $ex[1] eq 'END' and lc(config('server', 'ircd')) eq 'inspircd') {
        if (!$INSPIRCD_SERVICES_ACCOUNT_MOD) {
            error("chakora", "When using Chakora with InspIRCd, m_services_account.so is needed, please load it and try again!");
        }
        if (!$INSPIRCD_SERVICE_PROTECT_MOD) {
            print("[PROTOCOL] m_servprotect.so isn't loaded, it isn't required, but is recommended.\n");
        }
        raw_capabend();
    }
    # Charybdis: syncing done
    if ($ex[0] eq 'PING' and $synced != 1 and lc(config('server', 'ircd')) eq 'charybdis') {
	raw_endsync();
    }
    # Charybdis: Handle the SERVER while linking
    elsif ($ex[0] eq 'SERVER' and $synced != 1 and lc(config('server', 'ircd')) eq 'charybdis') {
	raw_server($data);
    }
    # Charybdis: Handle the PASS while linking
    elsif ($ex[0] eq 'PASS' and $synced != 1 and lc(config('server', 'ircd')) eq 'charybdis') {
        raw_pass($data);
    }
    # InspIRCd: Handle the SERVER while linking
    elsif ($ex[0] eq 'SERVER' and $synced != 1 and lc(config('server', 'ircd')) eq 'inspircd') {
	raw_lserver($data);
    }
    # Charybdis: Respond to PING's
    elsif ($ex[0] eq 'PING' and $synced != 0 and lc(config('server', 'ircd')) eq 'charybdis') {
	my @rex = split(' ', $data);
	send_sock(":".config('me', 'sid')." PONG ".$rex[1]);        
    }  
    # Charybdis: Local SQUIT's
    elsif ($ex[0] eq 'SQUIT' and lc(config('server', 'ircd')) eq 'charybdis') {
	raw_lsquit($data);
    }
    # IRCd: Respond to PING's
    elsif ($ex[0] eq 'PING' and lc(config('server', 'ircd')) eq 'ircd') {
	raw_ping($data);
    }
    # Error without a source
    elsif ($ex[0] eq 'ERROR') {
	raw_nosrcerror($data);
    }
 
    # Handle a server command, if a handler is defined in the protocol module
    if ($rawcmds{$ex[1]}{handler}) 
    {
        my $sub_ref = $rawcmds{$ex[1]}{handler};
        eval 
        {
            &{ $sub_ref }($data);
        };
    }
    # Handle CTCPs
    if ($mtext =~ /^\001.+\001/ and $ex[1] eq "PRIVMSG" and $ex[2] !~ m/#/) {
    	$data =~ s/\001//g;
    	$mtext =~ s/\001//g;
	$ex[3] =~ s/\001//g;
	$ex[3] = substr($ex[3], 1);
	handle_ctcp($USER, $ex[2], $ex[3]);
	print("[CTCP] ".$ex[3]." from ".$USER."[".uidInfo($USER, 1)."]\n");
    }

    # Handle services commands, if it exists
    elsif ($ex[1] eq "PRIVMSG" and $ex[2] !~ m/#/) {
	if ($ex[2] eq svsUID('cs') or $ex[2] eq config('chanserv', 'nick')) {
            $SERVICES_MSGSERVICE = "ChanServ";
            $SERVICES_MSGSERVICEA = "cs";
        } elsif ($ex[2] eq svsUID('hs') or $ex[2] eq config('hostserv', 'nick')) {
            $SERVICES_MSGSERVICE = "HostServ";
            $SERVICES_MSGSERVICEA = "hs";
        } elsif ($ex[2] eq svsUID('ms') or $ex[2] eq config('memoserv', 'nick')) {
            $SERVICES_MSGSERVICE = "MemoServ";
            $SERVICES_MSGSERVICEA = "ms";
        } elsif ($ex[2] eq svsUID('ns') or $ex[2] eq config('nickserv', 'nick')) {
            $SERVICES_MSGSERVICE = "NickServ";
            $SERVICES_MSGSERVICEA = "ns";
        } elsif ($ex[2] eq svsUID('os') or $ex[2] eq config('operserv', 'nick')) {
            $SERVICES_MSGSERVICE = "OperServ";
            $SERVICES_MSGSERVICEA = "os";
        }
        if ($COMMANDS{lc($SERVICES_MSGSERVICE)}{lc(substr($ex[3], 1))}{handler}) {
            my $sub_ref = $COMMANDS{lc($SERVICES_MSGSERVICE)}{lc(substr($ex[3], 1))}{handler};
            eval 
            {	
                &{ $sub_ref }($data);
            };
        } else {
            serv_notice($SERVICES_MSGSERVICEA, $USER, "Unknown command. Please see /msg ".config(lc($SERVICES_MSGSERVICE), "nick")." HELP for a list of commands.");
        }
    }
}

sub send_sock {
    my ($str) = @_;
    chomp($str);
    send($socket, $str."\r\n", 0);
    print("[YOU] ".$str."\n");
}

sub config {
    my ($block, $name) = @_;
    $block = lc($block);
    $name = lc($name);
    if (defined $settings->{$block}->{$name}) 
    {
        return $settings->{$block}->{$name};
    } else 
    {
        return 0;
    }
}

sub error {
    my ($type, $msg) = @_;
    print("[ERROR] ".$msg."\n");
    my ($file);
    if ($type ne 0) 
    {
        $type = lc($type);
        svsflog($type, "[ERROR] ".$msg);
    }
    exit;
}	

sub svsflog {
    my ($type, $str) = @_;
    my $file = $type.".log";
    unless (-d "$Bin/../var") {
        `mkdir $Bin/../var`;
    }
    `touch $Bin/../var/$file`;
    open FILE, ">>$Bin/../var/$file" or print("[FATAL] $file: Unable to open log file! Abort!\n") and exit;
    print FILE "(".scalar(localtime(time())).") ".$str."\n"; 
    close FILE; 
}

sub svsilog {
	my ($service, $user, $cmd, $args) = @_;
	if (length($args) == 0) {
		serv_privmsg($service, config('log', 'logchan'), uidInfo($user, 1).": \002".uc($cmd)."\002");
	}
	else {
		serv_privmsg($service, config('log', 'logchan'), uidInfo($user, 1).": \002".uc($cmd)."\002: ".$args);
	}
}

sub logchan {
	my ($service, $text) = @_;
	serv_privmsg($service, config('log', 'logchan'), $text);
}

sub module_init {
    my ($name, $author, $version, $init_handler, $void_handler, $ircd) = @_;
    print("[MODULES] Attempting to load module: ".$name." v".$version." by ".$author."\n");
    svsflog("chakora", "[MODULES] Attempting to load module: ".$name." v".$version." by ".$author);
    $ircd = lc($ircd);
    if ($ircd ne 'all' and $ircd ne lc(config('server', 'ircd'))) {
        print("[MODULES] Module ".$name." refusing to load: Protocol not supported.\n");
        svsflog("chakora", "[MODULES] Module ".$name." refusing to load: Protocol not supported.");
        return "MODLOAD_BADPROTO";
    } else {
        eval
        {
            &{ $init_handler }();
            print("[MODULES] ".$name.": Module successfully loaded.\n");
            svsflog("chakora", "[MODULES] ".$name.": Module successfully loaded.");
            $MODULE{$name}{name} = $name;
            $MODULE{$name}{author} = $author;
            $MODULE{$name}{version} = $version;
            $MODULE{$name}{void} = $void_handler;
            return "MODLOAD_SUCCESS";
            1;	
        } or print("[MODULES] ".$name.": Module failed to load.\n") and svsflog("chakora", "[MODULES] ".$name.": Module failed to load.") and return "MODLOAD_FAIL";
    }
}

sub module_exists {
	my ($module) = @_;
	my $exists = 0;
	foreach my $mod (keys %MODULE) {
		if ($mod eq $module) {
			$exists = 1;
		}
	}
	return $exists;
}

sub module_load {
	my ($module) = @_;
	if (-e $ROOT_SRC."/../modules/".lc($module).".pm") {
		require $ROOT_SRC."/../modules/".lc($module).".pm" and return 1 or return 0;
	}
	else {
		return 0;
	}
}

sub module_void {
	my ($module) = @_;
	svsflog("chakora", "[MODULES] ".$module.": Attempting to unload module. . .");
	if (defined($MODULE{$module})) {
		my $void_handler = $MODULE{$module}{void};
		eval
        {
            &{ $void_handler }();
            delete_sub $void_handler;
            print("[MODULES] ".$module.": Module successfully unloaded.\n");
            svsflog("chakora", "[MODULES] ".$module.": Module successfully unloaded.");
			undef $MODULE{$module};
            return "MODUNLOAD_SUCCESS";
			1;	
        } or print("[MODULES] ".$module.": Module failed to unload.\n") and svsflog("chakora", "[MODULES] ".$module.": Module failed to unload.") and return "MODUNLOAD_FAIL";
	} else {
		print("[MODULES] ".$module.": Module failed to unload. No such module?\n");
		svsflog("chakora", "[MODULES] ".$module.": Module failed to unload. No such module?");
		return "MODUNLOAD_NOEXIST";
	}	
}

sub cmd_add {
    my ($name, $shelp, $fhelp, $handler) = @_;
    my @rname = split('/', $name);
    $COMMANDS{$rname[0]}{$rname[1]}{name} = $name;
    $COMMANDS{$rname[0]}{$rname[1]}{handler} = $handler;
    $HELP{$name}{shelp} = $shelp;
    $HELP{$name}{fhelp} = $fhelp;
}

sub cmd_del {
	my ($cmd) = @_;
	my @scmd = split('/', $cmd);
	undef $COMMANDS{$scmd[0]}{$scmd[1]};
	undef $HELP{$cmd};
}

sub count {
	my (@array) = @_;
	my ($i, $ai);
	foreach $ai (@array) {
		$i += 1;
	}
	return $i;
}

sub taint {
	my ($str) = @_;
	my $msg = "TAINTED: ".$str;
	if (config('services', 'allow_taint')) {
		$msg .= " - ALLOW_TAINT enabled, ignoring taint. . .";
		print("[WARNING] ".$msg."\n");
	} else {
		$msg .= " - Aborting. . .";
		error("chakora", $msg);
	}	
}

sub handle_ctcp {
	my ($user, $svsuid, $ctcp) = @_;
	if (lc($ctcp) eq "version") {
		ctcp_reply($svsuid, $user, "VERSION", $SERVICES_VERSION);
	}
}

sub ctcp_reply {
	my ($svsuid, $user, $ctcp, $reply) = @_;
	send_sock(":".$svsuid." NOTICE ".$user." :\001".$ctcp." ".$reply."\001");
}

sub parse_mode {
	my ($modes, $key, $mode) = @_;
	if ($key eq '+') {
		my @kmodes = split('\+', $modes);
		my (@mmodes);
		foreach my $lmodes (@kmodes) {
			my @nmodes = split('-', $lmodes);
			if (defined $nmodes[0]) {
				push(@mmodes, $nmodes[0]);
			} else {
				push(@mmodes, $lmodes);
			}
		}
		my $ei = 0;
		foreach my $omodes (@mmodes) {
			if ($omodes =~ m/($mode)/) {
				$ei = 1;
			}
		}
		return $ei;
	}
	elsif ($key eq '-') {
		my @kmodes = split('-', $modes);
		my (@mmodes);
		foreach my $lmodes (@kmodes) {
			my @nmodes = split('\+', $lmodes);
			if (defined $nmodes[0]) {
				push(@mmodes, $nmodes[0]);
			} else {
				push(@mmodes, $lmodes);
			}
		}
		my $ei = 0;
		foreach my $omodes (@mmodes) {
			if ($omodes =~ m/($mode)/) {
				$ei = 1;
			}
		}
		return $ei;
	}
}

sub is_soper {
	my ($uid) = @_;
	if (uidInfo($uid, 7)) {
		return 1;
	}
	else {
		return 0;
	}
}

sub INT_handler {
	serv_quit("cs", "Caught SIGINT");
 	send_sock("SQUIT ".config('me', 'sid')." :SIGINT");
	svsflog("chakora", "Exiting on SIGINT");
	exit(0);
}
